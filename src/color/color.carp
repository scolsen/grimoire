(load "git@github.com:scolsen/carp-ncurses@master")
(load "colormap.carp")
(load "palette.carp")

(use NCurses)

(defmodule Grimoire
  (doc Color
    "Represents a color."
    "Each Color corresponds to an ncurses color pair."
    "Grimoire handles initializing and managing color pairs.")
  (deftype Color [id Int fg Int bg Int extended? Bool])

  ;; N.B. Coloring in NCurses is a bit nuanced for compatibility reasons.
  ;; If a terminal only supports 256 colors and 256 pairs, we can just use
  ;; attron and init-pair to set and specify colors.
  ;;
  ;; All other terminals need to use fields larger than shorts to store more
  ;; colors. For example, screen256 supports a greater number of pairs.
  ;; In this case, we need to use attr-set and init-extended-pair instead.
  ;; attr-set expects the color to be set in the third field, a pointer to its
  ;; id.
  ;;
  ;; the color extensions are only available in ncurses6.1 and greater.

  ;; TODO: Reset identifiers on overflow.
  ;; TODO: Add conditional logic for using extended pairs or not, based on
  ;; NCURSES patch version.
  (defmodule Color
    (hidden init) (hidden set-fg) (hidden set-bg)
    (hidden set-id) (hidden set-fg!) (hidden set-bg!)
    (hidden set-id!) (hidden fg) (hidden bg)
    (hidden id) (hidden update-id) (hidden update-fg) (hidden update-bg)

    (hidden next-identifier)
    (def next-identifier 1)

    ;; Why a macro? COLOR_PAIRS will return 0 until (start-color) is called.
    ;; evaluating the form now would likely result in an incorrect value.
    ;; Using a macro lets us get the right value, after the user has called
    ;; start-color
    (hidden max-identifier)
    (defmacro max-identifier [] '(dec NCurses.COLOR_PAIRS))

    (doc new "Initializes a new color.")
    (defn new [fg-code bg-code]
      (if (> (inc next-identifier) (max-identifier))
          (Result.Error @"Maximum number of color pairs allocated.")
          (let [ ok? (init-extended-pair next-identifier fg-code bg-code)]
            (if (= ok? NCurses.OK)
                (let-do [id next-identifier]
                  (set! next-identifier (inc next-identifier))
                  (Result.Success (Grimoire.Color id fg-code bg-code true)))
                (Result.Error @"Failed to initialize color.")))))

    (doc from-palette 
      "Initializes a new color using color codes from the given palette.")
    (defn from-palette [palette fg-key bg-key]
      (let [fg-code @(Grimoire.Palette.get palette fg-key)
            bg-code @(Grimoire.Palette.get palette bg-key)]
        (new fg-code bg-code)))

    (doc solid "Initializes a solid color.")
    (defn solid [color-code]
      (new color-code color-code))

    (doc solids "Initialize a solid color for each code in a Palette.")
    (defn solids [palette]
      (let-do [result []
               codes (Grimoire.Palette.codes palette)]
        (foreach [code codes]
          (match (solid @code)
                 (Result.Success color) (Array.push-back! &result color)
                 _ ()))
        result))

    (doc set-foreground "Sets the foreground value of a color.")
    (defn set-foreground! [color fg]
      (let [code (init-extended-pair @(Grimoire.Color.id &color)
                                     fg
                                     @(Grimoire.Color.bg &color))]
      (if (= code NCurses.OK)
          (Result.Success (set-fg color fg))
          (Result.Error @"Couldn't update foreground."))))

    (doc set-background "Sets the background value of a color.")
    (defn set-background! [color bg]
      (let [code (init-extended-pair @(Grimoire.Color.id &color)
                                     @(Grimoire.Color.fg &color)
                                     bg)]
        (if (= code NCurses.OK)
            (Result.Success (set-bg color bg))
            (Result.Error @"Couldn't update background."))))

    (doc update ("Updates the foreground and background of a color " false)
                "using the functions f and g, respectively.")
    (defn update [color f g]
      (let [fg (~f @(Grimoire.Color.fg &color))
            bg (~g @(Grimoire.Color.bg &color))
            code (init-extended-pair @(Grimoire.Color.id &color)
                                     fg
                                     bg)]
        (if (= code NCurses.OK)
            (Result.Success (set-bg (set-fg color fg) bg))
            (Result.Error @"Couldn't update color."))))

    (defn with-color [attr color]
      (if @(Grimoire.Color.extended? color)
          (attr-set attr (from-int 0) (address (Grimoire.Color.id color)))
          (attr-set attr (from-int (color-pair @(Grimoire.Color.id color))) NULL)))

    (defn on [color]
      (with-color A_NORMAL color))

    (defn off []
      (attr-set A_NORMAL (from-int 0) NULL))

    (defn swap-all! [palette f]
      (do (reset-color-pairs)
          (set! next-identifier 1)
          (~f palette)))

    (defn swap! [colors palette f]
      (let-do [last-id next-identifier
               seg-start @(Grimoire.Color.id (Array.unsafe-nth colors 0))]
        (set! next-identifier seg-start)
        (let-do [res (~f palette)]
          (set! next-identifier last-id)
          res)))

    (defn clear-all! []
      (do (reset-color-pairs)
          (set! next-identifier 1)))

    (doc with-color*
      ("Turns on the NCurses color attribute" false)
      ("corresponding to color before executing `forms`. " false)
      "Turns the color off afterwards.")
    (defmacro with-color* [color form]
      (list 'do (list 'ignore (list 'with-color 'A_NORMAL color))
                form
                (list 'ignore (list 'Grimoire.Color.off))))
  )
)
